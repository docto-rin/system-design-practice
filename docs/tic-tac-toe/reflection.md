# Tic Tac Toe 実装の振り返り

## 概要

初めて Low Level Design (LLD) の流れに沿って、要件定義から実装まで一通りやってみた。普段 Python を使っていて、Java は文法を読んだ程度だったので、実装しながら学ぶ形になった。

## 学んだこと

### LLD のプロセス
要件定義 -> エンティティ識別 -> クラス設計 -> 実装という流れは、いきなりコードを書くよりずっと見通しが良かった。特にクラス図を先に書いたことで、各クラスの責務が明確になった。

### Java の機能
- `Optional<T>` で null を避ける設計ができた。`checkWinner()` の戻り値を Optional にしたことで、「勝者なし」の状態を明確に表現できた
- enum の `toString()` をオーバーライドして、表示用の文字列を制御できることを知った
- varargs（可変長引数）を使って `checkLine(Symbol... symbols)` を書けた
- package-private でテスト用のメソッドを公開しすぎない設計ができた

### テスト駆動開発
先にテストを書いてから実装する流れは、最初は面倒に感じたけど、後から見ると動作保証になっていて安心感があった。特に `display()` を `getDisplayString()` に分離してテスト可能にしたのは良い設計だと思う。

### 最適化
`Board.isFull()` を O(n²) から O(1) に改善できた。`emptyCount` フィールドを持つことで、毎回グリッド全体を走査する必要がなくなった。

## よくなかった点

### テスタビリティの問題
`Game.play()` が `Scanner(System.in)` と密結合していて、自動テストができない。標準入力を使う部分とロジックを分離すべきだった。現状では `parseCoordinate()` しかテストできていない。

### エラーハンドリング
無効な入力に対してメッセージを出して再入力を促すだけで、例外処理は実装していない。エッジケースをどこまで考慮するかの判断が難しかった。

### 設計の見直し
実装中に「これで良いのか？」と迷う場面が何度かあった。特に、
- Board が範囲チェックをすべきか、Game がすべきか
- getSymbol() を public にするべきか
- テストクラスをどう分割するか

こういう判断基準がまだ身についていないと感じた。

## 次にやりたいこと

### リファクタリング
動くコードは書けたけど、より良い設計に改善する余地はまだある。特にテスタビリティと責務の分離をもっと意識したい。

### 依存性注入を学ぶ
`Game` クラスに `Scanner` や `InputStream` を外部から渡せるようにして、テスト可能な設計にしたい。現状の設計では手動での統合テストしかできない。

## 模範解答を見て思ったこと

https://github.com/ashishps1/awesome-low-level-design/tree/main/solutions/java/src/tictactoe の実装を見てみた。

自分の実装と比べると、
- Cell クラスを作るという発想がなかった。自分は `Symbol[][]` で直接管理していたけど、Cell として抽象化する方が拡張性が高い
- State Pattern でゲームの状態管理をしていた。自分は単純な if 文で判定していたので、状態が増えたら破綻しそう
- Observer Pattern でゲームイベントを通知する設計になっていた。UI との分離を考えるとこういう設計が必要になるんだと理解できた
- ディレクトリ構造が `enums/`, `models/`, `strategy/` などに整理されていて、規模が大きくなっても保守しやすそう

一方で、学習の第一歩としては自分のシンプルな実装で良かったと思う。いきなり複数のデザインパターンを使うと、何が本質的な設計で何がパターンによる複雑さなのか分からなくなっていたかもしれない。

次はもう少し複雑な問題で、これらのパターンを意識しながら設計してみたい。
